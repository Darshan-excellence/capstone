#!/usr/bin/env python

from __future__ import print_function
import sys
import bitstring
from capstone import *
from capstone.m68k import *
from xprint import to_hex, to_x

#
# Objdump with the same output as his binary cousin
#

TODO = """
TODO :

  o bitwise mnemonic are not decoded
  o need more testing/implementation : M68K_AM_REGI_ADDR and others MEMI, PCI, PC, ABSOLUTE
  o cleanup, etc ...

"""

objdump_cmd_example = 'm68k-atari-mint-objdump -b binary -D -mm68k --adjust-vma 0x30664 u/m68k.bin'
objdump_dumpheader_fmt = """
%s:     file format binary


Disassembly of section .data:

%08x <.data>:"""


M68000_CODE = b"\x04\x40\x00\x40"

all_tests = (
        (CS_ARCH_M68K, CS_MODE_BIG_ENDIAN | CS_MODE_M68K_060, M68000_CODE, "M68060-32 (Big-endian)"),
)


def dump_bytes(b, len):
    str = ''
    i = 0
    while i < len:
        str += format("%02x%02x " % (b[i], b[i+1]))
        i += 2
    return str[:-1]

def dump_op_reg(insn, op_reg):
    if op_reg == M68K_REG_A7:
        return "%sp"
    if op_reg == M68K_REG_A6:
        return "%fp"
    return '%' + insn.reg_name(op_reg)

def s8(value):
    return bitstring.Bits(uint=value, length=8).unpack('int')[0]

def s16(value):
    return bitstring.Bits(uint=value, length=16).unpack('int')[0]

def dump_op_ea(insn, op):
    if op.address_mode == M68K_AM_REG_DIRECT_ADDR:
        return dump_op_reg(insn, op.reg) + "@"
    if op.address_mode == M68K_AM_REGI_ADDR:
        return dump_op_reg(insn, op.reg) + "fixme-iaddr"
    if op.address_mode == M68K_AM_REGI_ADDR_POST_INC:
        return dump_op_reg(insn, op.reg) + "@+"
    if op.address_mode == M68K_AM_REGI_ADDR_PRE_DEC:
        return dump_op_reg(insn, op.reg) + "@-"
    if op.address_mode == M68K_AM_REGI_ADDR_DISP:
        return dump_op_reg(insn, op.reg) + format("@(%d)" % s16(op.mem.disp))
    return ''

def dump_ops(insn):
    str = ''
    i = 0
    while i < len(insn.operands):
        if i > 0:
            str += ','
        mnemonic = insn.insn_name()
        op = insn.operands[i]
        if mnemonic == "illegal":
            str += format("0x%04x" % (op.imm))
            break
        if op.type == M68K_OP_REG:
            str_op_reg = dump_op_ea(insn, op)
            if str_op_reg == '' or op.address_mode == M68K_AM_REG_DIRECT_ADDR:
                str_op_reg = dump_op_reg(insn, op.reg)
            str += str_op_reg
        if op.type == M68K_OP_IMM:
            str_op_imm = format("#%u" % (op.imm))
            if mnemonic in ["bkpt"]:
                str_op_imm = format("%u" % (op.imm))
            signed_insn = [ "move", "moveq", "cmp", "cmpi", "ori", "bclr", "pack", "unpk" ]
            if mnemonic in signed_insn:
                if insn.op_size.size == 1 or mnemonic == "moveq":
                    str_op_imm = format("#%d" % s8(op.imm))
                if insn.op_size.size == 2 or mnemonic == "pack":
                    str_op_imm = format("#%d" % s16(op.imm))
                if insn.op_size.size == 4:
                    str_op_imm = format("#%d" % (op.imm))

            dbxx_insn = [ "dbt", "dbf", "dbhi", "dbls", "dbcc", "dbcs", "dbne", "dbeq", "dbvc", "dbvs", "dbpl", "dbmi", "dbge", "dblt", "dbgt", "dble", "dbra" ]
            if is_branch(insn) or mnemonic in dbxx_insn:
                str_op_imm = format("0x%x" % (op.imm))
            str += str_op_imm
        if op.type == M68K_OP_MEM:
            str_op_mem = dump_op_ea(insn, op)
            if str_op_mem == '':
                str_op_mem = format("0x%x" % (op.imm))
            str += str_op_mem
#        if insn.address == 0x3127c:
#            import pdb;pdb.set_trace()
#        print("type %u am %u\n" % (op.type, op.address_mode))    
        i += 1
    return str


def is_branch(insn):
    mnemonic = insn.insn_name()
    branch_insn = [ "bsr", "bra", "bhi", "bls", "bcc", "bcs", "bne", "beq", "bvc", "bvs", "bpl", "bmi", "bge", "blt", "bgt", "ble" ];
    return mnemonic in branch_insn

def dump_mnemonic(insn):
    mnemonic = insn.insn_name()
    ext = { 0: '', 1:'b', 2:'w', 4:'l' }
    if is_branch(insn):
        ext.update({ 1:'s', 2:'w', 4:'l' })
    
    no_size = [ "pea", "lea", "bclr", "bchg", "btst", "nbcd", "abcd", "sbcd", "exg", "scc", "sls", "scs", "shi" ]
    sxx_insn = [ "st", "sf", "shi", "sls", "scc", "scs", "sne", "seq", "svc", "svs", "spl", "smi", "sge", "slt", "sgt", "sle", "stop" ]
    no_size += sxx_insn
    if mnemonic in no_size:
        ext.update({ 0:'', 1:'', 2:'', 4:'' })
    if mnemonic == "illegal":
        return ".short"
    return mnemonic + ext[insn.op_size.size]

def print_insn_detail_np(insn):
    # "data" instruction generated by SKIPDATA option has no detail
    if insn.id == 0:
        return

    # objdump format hack
    if insn.size == 2:
        space = ' ' * 11
    if insn.size == 4:
        space = ' ' * 6
    if insn.size >= 6:
        space = ' '
    space_ops = ''
    if len(insn.operands) > 0:
        space_ops = ' '

    print("   %x:\t%s%s\t%s%s%s" % (insn.address, dump_bytes(insn._raw.bytes, min(insn.size, 6)), space, dump_mnemonic(insn), space_ops, dump_ops(insn)))

    if insn.size > 6:
        delta = min(insn.size, 6)
        print("   %x:\t%s " % (insn.address+delta, dump_bytes(insn._raw.bytes[delta:], min(insn.size-delta, 6))))

          
def print_objdump_dumpheader(filename='', address=0):
    print(objdump_dumpheader_fmt % (filename, address))

# ## Test class Cs
def test_class():
    for (arch, mode, code, comment) in all_tests:
        filename = "/dev/stdin"
        address = 0
        if len(sys.argv) > 1:
            filename = sys.argv[1]
        if len(sys.argv) > 2:
            address = int(sys.argv[2],16)
            
        with open(filename, "rb") as f:
            code = f.read()

        try:
            md = Cs(arch, mode)
            md.detail = True

            print_objdump_dumpheader(filename, address)
            
            for insn in md.disasm(code, address):
                print_insn_detail_np(insn)

        except CsError as e:
            print("ERROR: %s" % e)


if __name__ == '__main__':
    test_class()
